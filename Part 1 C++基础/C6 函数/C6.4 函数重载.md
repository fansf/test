# C6.4 函数重载
如果同一作用域内的几个函数名字相同但形参列表不同，我们称之为**重载（overload）函数**。

例如：
```cpp
void print(const char *cp);
void print(const int *beg,const int *end);
void print(const int ia[],size_t size);
```

这些函数接收的形参类型不一样，但是执行的操作非常相似。当调用这些函数时，编译器会根据传递的实参类型推断想要的是哪个函数。

函数的名字仅仅是让编译器知道它调用的是哪个函数，而函数重载可以再一定程度上减轻程序员起名字、记名字的负担。

NOTE：  
> main函数不能重载

**定义重载函数**  

对于重载函数来说，它们应该在形参数量或者形参类型上有所不同。

不允许两个函数除了返回类型外其他的所有要素都相同。

**重载和const形参**  

顶层`const`不影响传入函数的对象。一个拥有顶层`const`的形参无法和另外一个没有顶层`const`的形参区分开来。

另一方面，如果形参是某种类型的指针或引用，则通过区分其指向的是常量对象还是非常量对象可以实现函数重载，此时的`const`是底层的。

```cpp
int func(int&);        //函数作用于int的引用
int func(const int&);  //新函数，作用于常量引用

int func(int*);
int func(const int*);  //新函数，作用于指向常量的指针
```

因为`const`不能转换成其他类型的，所以我们只能把`const`对象（或指向`const`的指针）传递给`const`形参。相反的，因为非常量可以转换成`const`，所以上面的4个函数都能作用于非常量对象或者指向非常量对象的指针。

**调用重载函数**  

定义了一组函数后，我们需要以合理的实参调用它们。**函数匹配（function matching）** 是指一个过程，在这个过程中我们把函数调用与一组重载函数中的某一个关联起来，函数匹配也叫做**重载确定 （overload resolution）**。 编译器首先将调用的实参与重载集合中每一个函数的形参进行比较，然后根据比较的结果决定到底调用哪个函数。

当调用重载函数时有三种可能的结果：
- 编译器找到一个与实参最佳匹配的函数，并生成调用该函数的代码。
- 找不到任何一个函数与调用的实参匹配，此时编译器发出无匹配的错误信息。
- 有多于一个函数可以匹配，但是每一个都不是明显的最佳选择。此时也将发生错误，称为**二义性调用（ambiguous call）**。

## 重载与作用域
重载对作用域的一般性质并没有什么改变：如果我们在内层作用域中声明名字，它将隐藏外层作用域中声明的同名实体。在不同的作用域中无法重载函数名。

在C++语言中，名字查找发生在类型检查之前。