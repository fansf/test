# C6.3 返回类型和return语句
`return`语句终止当前正在执行的函数并将控制权返回到调用函数的地方。`return`语句有两种形式：
```cpp
return;
return expression;
```

## 无返回值函数
没有返回值的`return`语句只能用在返回类型是`void`的函数中。返回`void`的函数不要求非得有`return`语句，因为在这类函数的最后一句后面会隐式地执行`return`。

通常情况下，`void`函数如果想在它的中间位置提前退出，可以使用`return`语句。`return`的这种用法有点类似于我们用`break`语句退出循环。

一个返回类型是`void`的函数也能使用`return`语句的第二种形式，不过此时`return`语句的*expression*必须是另一个返回`void`的函数。强行令`void`函数返回其他类型的表达式将产生编译错误。

## 有返回值函数
`return`语句的第二种形式提供了函数的结果。只要函数的返回类型不是`void`，则该函数内的每条`return`语句必须返回一个值。`return`语句返回值的类型必须与函数的返回类型相同，，或者能隐式地转换成函数的返回类型。

尽管C++无法确保结果的正确性，但是可以保证每个`return`语句的结果类型正确。也许无法顾及所有情况，但是编译器仍然尽量确保具有返回值的函数只能通过一条有效的`return`语句退出。例如：
```cpp
bool str_subrange(const string &str1,const string &str2)
{
    if (str1.size() == str2.size())
        return str1.size() == str2.size();    //正确：==运算符返回布尔值
    auto size = (str1.size(0 < str2.size()) ? str1.size() : str2.size();
    for (decltype(size) i = 0;i != size; ++i){
        if (str1[i] != str2[i])
            return;                           //错误：没有返回值，编译器将报告这一错误
    }
    //错误：控制流可能尚未返回任何值就结束了函数的执行
    //编译器可能检查不出这一错误
}
```

### 值是如何被返回的
返回一个值的方式和初始化一个变量或形参的方法完全一样：返回的值用于初始化调用点的一个临时量，该临时量就是函数调用的结果。

同其他引用类型一样，如果函数返回引用，则该引用仅是它所引用对象的一个别名。

### 不要返回局部对象的引用或指针
函数完成后，它所占用的存储空间也随之被释放掉。因此，函数终止意味着局部变量的引用将指向不再有效的内存区域。
```cpp
const string& manip()
{
    string ret;
    //以某个方式改变一下ret
    if (!ret.empty())
        return ret;            //错误：返回局部对象的引用
    else
        return "Empty";        //错误：“empty”是一个局部变量
}
```

同样，返回局部对象的指针也是错误的。一旦函数完成，局部对象被释放，指针将指向一个不存在的对象。

### 返回类类型的函数和调用运算符
和其他运算符一样，调用运算符也有优先级和结合律。调用运算符的优先级与点运算符和箭头运算符相同，并且也符合左结合律。因此，如果函数返回指针、引用或类的对象，我们就能使用函数调用的结果访问结果对象的成员。

例如，我们可以通过如下形式得到较短`string`对象的长度：
```cpp
auto sz = shorterString(s1,s2).size();
```

因为上面提到的运算符都满足左结合律，所以`shorterString`的结果是点运算符的左侧运算对象，点运算符可以得到该`string`对象的`size`成员，`size`又是第二个调用运算符的左侧运算对象。

### 引用返回左值
函数的返回类型决定了函数调用是否是左值。调用一个返回引用的函数得到左值，其他返回类型得到右值。可以向使用其他左值那样来使用返回引用的函数的调用，特别是，我们能为返回类型是非常量引用的函数的结果赋值：
```cpp
char &get_val(string &str,string::size_type ix)
{
    return str[ix];    //get_val假定索引值是有效的
}

int main()
{
    string s("a value");
    cout << s << endl;
    get_val(s,0) = 'A';    //将s[0]的值修改成A
    cout << s << endl;
    return 0;
}
```

把函数调用放在赋值语句的左侧可能看起来有点奇怪，但其实这没有什么特别的。返回值是引用，因此调用是个左值，和其他左值一样它也可能出现在赋值运算符的左侧。

如果返回类型是常量引用，我们不能给调用的结果赋值，这一点和我们熟悉的情况是一样的：
```cpp
shorterString("hi","bye") = "X";    //错误：返回值是个常量
```

### 主函数main的返回值
`main`函数的返回值可以看作是状态指示器。返回0表示执行成功，返回其他值表示执行失败，其中非0值的具体含义视及其而定。为了使返回值与机器无关，`cstdlib`头文件定义了两个预处理变量，我们可以使用这两个变量分别表示成功与失败：
```cpp
int main()
{
    if (some_failure)
        return EXIT_FAILURE;
    else
        return EXIT_SUCCESS;
}
```

### 递归
如果一个函数调用了它自身，不管这种调用是直接的还是间接的，都称该函数为**递归函数（recursive function）** 。

## 返回数组指针
因为数组不能拷贝，所以函数不能返回数组。不过，函数可以返回数组的指针或引用。

最简单直接的方法是使用类型别名：
```cpp
typedef int arrT[10];           //arrT是一个类型别名，它表示的类型是含有10个整数的数组
using arrT = int[10];           //arrT的等价声明
arrT* func(int i);              //func返回一个指向含有10个整数的数组的指针
```

### 声明一个返回数组指针的函数
要想在声明`func`时不使用类型别名，我们必须牢记被定义的名字后面数组的维度：
```cpp
int arr[10];             //arr是一个含有10个整数的数组
int *p1[10];             //p1是一个含有10个指针的数组
int (*p2)[10] = &arr;    //p2是一个指针，它指向含有10个整数的数组
```

和这些声明一样，如果我们想定义一个返回数组指针的函数，则数组的维度必须跟在函数名字之后。然而，函数的形参列表也跟在函数名字后面且形参列表应该先于数组的维度。因此，返回数组指针的函数形式如下所示：
```cpp
Type (*function(parameter_list))[dimension]
```

类似于其他数组的声明，*Type*表示元素的类型，*dimension*表示数组的大小。*(\*function(parameter_list)*两端的括号必须存在，如果没有这对括号，函数的返回类型将是指针的数组。

下面这个`func`函数的声明没有使用类型别名：
```cpp
int (*func(int i))[10];
```

### 使用尾置返回类型
在C++11 新标准中还有一种可以简化上述`func`声明的方法，就是使用**尾置返回类型（trailing return type）**。 任何函数的定义都能使用尾置返回，但是这种返回类型对于比较复杂的函数最有效，比如返回类型是数组的指针或者数组的引用。尾置返回类型跟在形参列表后面并以一个`->`符号开头。为了表示函数真正的返回类型跟在形参列表之后，我们在本应该出现返回类型的地方放置一个`auto`.
```
auto func(int i) -> int(*)[10];
```

因为我们把返回类型放在了形参列表之后，所以可以清楚地看到`func`函数返回的是一个指针，并且该指针指向了含有10个整数的数组。